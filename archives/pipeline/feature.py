from abc import ABC, abstractmethod
from dataclasses import dataclass
import polars as pl
from typing import Iterator


class FeatureStep(ABC):
    """Abstract base class for feature computation steps"""

    @abstractmethod
    def compute_expressions(self, interval: str | None) -> Iterator[list[pl.Expr]]:
        """
        Returns list of Polars expressions to compute this feature.
        Each yield define boundaries where intermediate DataFrames
        must be built to call the next list of Expr.
        """
        pass

    @property
    @abstractmethod
    def required_columns(self) -> list[str]:
        """Columns required by this step"""
        pass

    @property
    @abstractmethod
    def required_columns_in_agg(self) -> list[pl.Expr]:
        """Columns required by this step in aggregation"""
        pass

    @property
    @abstractmethod
    def generated_columns(self) -> list[str]:
        """Columns generated by this step"""
        pass

    @property
    def required_windows(self) -> list[int]:
        """Returns all window sizes required by this step"""
        return []


@dataclass(frozen=True)
class Intervals:
    """Time intervals used for resampling and analysis"""

    MINUTE_1: str = "1m"
    MINUTE_5: str = "5m"
    HOUR_1: str = "1h"
    DAY_1: str = "1d"
    WEEK_1: str = "1w"

    @classmethod
    def get_all(cls) -> list[str]:
        """Returns all interval values"""
        return [
            cls.MINUTE_1,
            cls.MINUTE_5,
            cls.HOUR_1,
            cls.DAY_1,
            cls.WEEK_1,
        ]

    @classmethod
    def get_ordered(cls) -> list[str]:
        """Returns intervals ordered from largest to smallest"""
        return [
            cls.WEEK_1,
            cls.DAY_1,
            cls.HOUR_1,
            cls.MINUTE_5,
            cls.MINUTE_1,
        ]


@dataclass(frozen=True)
class TechnicalWindows:
    """Window sizes for technical indicators"""

    @dataclass(frozen=True)
    class MA:
        """Moving Average windows"""

        FAST: int = 12
        MEDIUM: int = 26

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.FAST, cls.MEDIUM]

    @dataclass(frozen=True)
    class Volatility:
        """Volatility windows"""

        DEFAULT: int = 20

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.DEFAULT]

    @dataclass(frozen=True)
    class ROC:
        """Rate of Change windows"""

        SHORT: int = 12
        MEDIUM: int = 25

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.SHORT, cls.MEDIUM]

    @dataclass(frozen=True)
    class RSI:
        """Relative Strength Index windows"""

        DEFAULT: int = 14

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.DEFAULT]

    @dataclass(frozen=True)
    class Stochastic:
        """Stochastic Oscillator windows"""

        K: int = 14  # %K periods (raw stochastic)
        D: int = 3  # %D periods (3-period moving average of %K)

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.K, cls.D]

    @dataclass(frozen=True)
    class VMA:
        """Volume Moving Average windows"""

        SHORT: int = 20

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.SHORT]

    @dataclass(frozen=True)
    class MACD:
        """Moving Average Convergence Divergence windows"""

        FAST: int = 12
        SLOW: int = 26
        SIGNAL: int = 9

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.FAST, cls.SLOW, cls.SIGNAL]

    @dataclass(frozen=True)
    class Williams:
        """Williams %R window"""

        DEFAULT: int = 14

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.DEFAULT]

    @dataclass(frozen=True)
    class DMS:
        """Directional Movement System windows (ADX, +DI, -DI)"""

        DEFAULT: int = 14  # Used +DI, -DI and ADX

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.DEFAULT]

    @dataclass(frozen=True)
    class Lagging:
        """Windows for lagging indicators"""

        VERY_SHORT: int = 5
        SHORT: int = 10
        MEDIUM: int = 20

        # Pattern detection windows
        PATTERN_SHORT: int = 3
        PATTERN_MEDIUM: int = 5

        @classmethod
        def get_all(cls) -> list[int]:
            return [cls.VERY_SHORT, cls.SHORT, cls.MEDIUM]

        @classmethod
        def get_pattern_windows(cls) -> list[int]:
            return [cls.PATTERN_SHORT, cls.PATTERN_MEDIUM]


@dataclass(frozen=True)
class Columns:
    """Column names for DataFrame"""

    # Base columns
    DATETIME: str = "datetime"
    OPEN: str = "open"
    HIGH: str = "high"
    LOW: str = "low"
    CLOSE: str = "close"
    VOLUME: str = "volume"
    QUOTE_ASSET_VOLUME: str = "quote_asset_volume"
    NUMBER_OF_TRADES: str = "number_of_trades"
    TAKER_BUY_BASE_VOLUME: str = "taker_buy_base_volume"
    TAKER_BUY_QUOTE_VOLUME: str = "taker_buy_quote_volume"
    TARGET: str = "target"

    # Pattern detection columns
    TRIPLE_REPEAT: str = "triple_repeat"
    ALTERNATING_PATTERN: str = "alternating_pattern"
    RECENT_MAJORITY_UP: str = "recent_majority_up"

    # Technical indicator column templates
    @staticmethod
    def ema(window: int) -> str:
        return f"ema_{window}"

    @staticmethod
    def sma(window: int) -> str:
        return f"sma_{window}"

    @staticmethod
    def rsi(window: int) -> str:
        return f"rsi_{window}"

    @staticmethod
    def roc(window: int) -> str:
        return f"roc_{window}"

    @staticmethod
    def volatility(window: int) -> str:
        return f"volatility_{window}"

    @staticmethod
    def vma(window: int) -> str:
        return f"vma_{window}"

    @staticmethod
    def stoch_k(k_window: int) -> str:
        return f"stoch_k_{k_window}"

    @staticmethod
    def stoch_d(k_window: int, d_window: int) -> str:
        return f"stoch_d_{k_window}_{d_window}"

    @staticmethod
    def williams_r(window: int) -> str:
        return f"williams_r_{window}"

    @staticmethod
    def adx(window: int) -> str:
        return f"adx_{window}"

    @staticmethod
    def plus_di(window: int) -> str:
        return f"plus_di_{window}"

    @staticmethod
    def minus_di(window: int) -> str:
        return f"minus_di_{window}"

    @staticmethod
    def macd(fast_window: int, slow_window: int) -> str:
        return f"macd_{fast_window}_{slow_window}"

    @staticmethod
    def macd_signal(fast_window: int, slow_window: int, signal_window: int) -> str:
        return f"macd_{fast_window}_{slow_window}_signal_{signal_window}"

    @staticmethod
    def macd_histogram(fast_window: int, slow_window: int, signal_window: int) -> str:
        return f"macd_{fast_window}_{slow_window}_hist_{signal_window}"

    @staticmethod
    def streak_length() -> str:
        return "current_streak_length"

    @staticmethod
    def streak_direction() -> str:
        return "streak_direction"

    @staticmethod
    def time_since_change() -> str:
        return "time_since_direction_change"

    @staticmethod
    def target_ratio(window: int) -> str:
        return f"target_ratio_{window}"

    @staticmethod
    def direction_changes(window: int) -> str:
        return f"direction_changes_{window}"

    @staticmethod
    def target_volatility(window: int) -> str:
        return f"target_volatility_{window}"

    @staticmethod
    def target_acceleration(window: int) -> str:
        return f"target_acceleration_{window}"

    @staticmethod
    def pattern_last_n(window: int) -> str:
        return f"pattern_last_{window}"

    @classmethod
    def get_base_columns(cls) -> list[str]:
        """Returns list of base columns"""
        return [
            cls.DATETIME,
            cls.OPEN,
            cls.HIGH,
            cls.LOW,
            cls.CLOSE,
            cls.VOLUME,
            cls.QUOTE_ASSET_VOLUME,
            cls.NUMBER_OF_TRADES,
            cls.TAKER_BUY_BASE_VOLUME,
            cls.TAKER_BUY_QUOTE_VOLUME,
            cls.TARGET,
        ]

    @classmethod
    def get_price_columns(cls) -> list[str]:
        """Returns list of price-related columns"""
        return [cls.OPEN, cls.HIGH, cls.LOW, cls.CLOSE]

    @classmethod
    def get_volume_columns(cls) -> list[str]:
        """Returns list of volume-related columns"""
        return [
            cls.VOLUME,
            cls.QUOTE_ASSET_VOLUME,
            cls.TAKER_BUY_BASE_VOLUME,
            cls.TAKER_BUY_QUOTE_VOLUME,
        ]

    @classmethod
    def get_lagging_columns(cls, windows: list[int]) -> list[str]:
        """Returns all lagging indicator columns for given windows"""
        base_columns = [
            cls.streak_length(),
            cls.streak_direction(),
            cls.time_since_change(),
            cls.TRIPLE_REPEAT,
            cls.ALTERNATING_PATTERN,
            cls.RECENT_MAJORITY_UP,
        ]

        window_columns = []
        for window in windows:
            window_columns.extend(
                [
                    cls.target_ratio(window),
                    cls.direction_changes(window),
                    cls.target_volatility(window),
                    cls.target_acceleration(window),
                ]
            )

        pattern_columns = [
            cls.pattern_last_n(w)
            for w in TechnicalWindows.Lagging.get_pattern_windows()
        ]

        return base_columns + window_columns + pattern_columns
